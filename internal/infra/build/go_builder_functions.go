// Where: cli/internal/infra/build/go_builder_functions.go
// What: Function image build helpers and shared image naming utilities.
// Why: Isolate function-image-specific logic from GoBuilder orchestration.
package build

import (
	"context"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/poruru/edge-serverless-box/cli/internal/domain/template"
	"github.com/poruru/edge-serverless-box/cli/internal/infra/compose"
	"github.com/poruru/edge-serverless-box/meta"
)

func brandingImageLabels(project, env string) map[string]string {
	labels := map[string]string{
		compose.ESBManagedLabel: "true",
	}
	if trimmed := strings.TrimSpace(project); trimmed != "" {
		labels[compose.ESBProjectLabel] = trimmed
	}
	if trimmed := strings.TrimSpace(env); trimmed != "" {
		labels[compose.ESBEnvLabel] = trimmed
	}
	return labels
}

func lambdaBaseImageTag(registry, tag string) string {
	imageTag := fmt.Sprintf("%s-lambda-base:%s", meta.ImagePrefix, tag)
	return joinRegistry(registry, imageTag)
}

func joinRegistry(registry, image string) string {
	if registry == "" {
		return image
	}
	if strings.HasSuffix(registry, "/") {
		return registry + image
	}
	return registry + "/" + image
}

func buildFunctionImages(
	ctx context.Context,
	runner compose.CommandRunner,
	repoRoot string,
	lockRoot string,
	outputDir string,
	functions []template.FunctionSpec,
	registry string,
	tag string,
	noCache bool,
	verbose bool,
	labels map[string]string,
	includeDocker bool,
	out io.Writer,
) error {
	out = resolveBuildOutput(out)
	if verbose {
		_, _ = fmt.Fprintln(out, "Building function images...")
	}
	proxyArgs := dockerBuildArgMap()
	expectedFingerprint := strings.TrimSpace(labels[compose.ESBImageFingerprintLabel])
	bakeTargets := make([]bakeTarget, 0, len(functions))
	for _, fn := range functions {
		if verbose {
			_, _ = fmt.Fprintf(out, "  Building image for %s...\n", fn.Name)
		}
		if strings.TrimSpace(fn.Name) == "" {
			return fmt.Errorf("function name is required")
		}
		if strings.TrimSpace(fn.ImageName) == "" {
			return fmt.Errorf("function image name is required for %s", fn.Name)
		}
		functionDir := filepath.Join(outputDir, "functions", fn.Name)
		dockerfile := filepath.Join(functionDir, "Dockerfile")
		if _, err := os.Stat(dockerfile); err != nil {
			return fmt.Errorf("dockerfile not found: %w", err)
		}
		if err := writeFunctionDockerignore(outputDir, functionDir); err != nil {
			return err
		}

		imageTag := fmt.Sprintf("%s-%s:%s", meta.ImagePrefix, fn.ImageName, tag)
		imageTag = joinRegistry(registry, imageTag)

		skipBuild := false
		if !noCache && expectedFingerprint != "" {
			if dockerImageHasLabelValue(ctx, runner, outputDir, imageTag, compose.ESBImageFingerprintLabel, expectedFingerprint) {
				skipBuild = true
				if verbose {
					_, _ = fmt.Fprintf(out, "  Skipping %s (up-to-date)\n", fn.Name)
				}
			}
		}
		if !skipBuild {
			target := bakeTarget{
				Name:       "fn-" + fn.ImageName,
				Context:    outputDir,
				Dockerfile: dockerfile,
				Tags:       []string{imageTag},
				Outputs:    resolveBakeOutputs(registry, true, includeDocker),
				Labels:     labels,
				Args:       proxyArgs,
				NoCache:    noCache,
			}
			bakeTargets = append(bakeTargets, target)
		}
	}

	if len(bakeTargets) > 0 {
		if err := runBakeGroup(
			ctx,
			runner,
			repoRoot,
			lockRoot,
			"esb-functions",
			bakeTargets,
			verbose,
		); err != nil {
			return err
		}
	}
	return nil
}

func writeFunctionDockerignore(contextDir, functionDir string) error {
	rel, err := filepath.Rel(contextDir, functionDir)
	if err != nil {
		return fmt.Errorf("resolve dockerignore path: %w", err)
	}
	rel = filepath.ToSlash(rel)
	if rel == "." || strings.HasPrefix(rel, "../") {
		return nil
	}
	parts := strings.Split(rel, "/")
	if len(parts) == 0 || parts[0] != "functions" {
		return nil
	}

	lines := []string{
		fmt.Sprintf("# Auto-generated by %s build.", meta.AppName),
		"# What: Limit Docker build context to the active function and its layers.",
		"# Why: Reduce context upload size when using output_dir as build context.",
		"*",
		"!.dockerignore",
		"!functions/",
		"!" + rel + "/",
		"!" + rel + "/**",
	}
	content := strings.Join(lines, "\n") + "\n"
	return os.WriteFile(filepath.Join(contextDir, ".dockerignore"), []byte(content), 0o600)
}
