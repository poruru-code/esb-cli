// Where: cli/internal/infra/build/bake.go
// What: Buildx bake helpers for parallel image builds.
// Why: Speed up ESB build phase by batching images with bake.
package build

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"

	"github.com/poruru/edge-serverless-box/cli/internal/infra/compose"
	"github.com/poruru/edge-serverless-box/meta"
)

type bakeTarget struct {
	Name          string
	Context       string
	Dockerfile    string
	Tags          []string
	Outputs       []string
	Labels        map[string]string
	Args          map[string]string
	Contexts      map[string]string
	Secrets       []string
	CacheFrom     []string
	CacheTo       []string
	CacheDisabled bool
	NoCache       bool
}

func buildxBuilderName() string {
	if value := strings.TrimSpace(os.Getenv("BUILDX_BUILDER")); value != "" {
		return value
	}
	return fmt.Sprintf("%s-buildx", meta.Slug)
}

func runBakeGroup(
	ctx context.Context,
	runner compose.CommandRunner,
	repoRoot string,
	groupName string,
	targets []bakeTarget,
	verbose bool,
) error {
	if runner == nil {
		return fmt.Errorf("command runner is nil")
	}
	if strings.TrimSpace(repoRoot) == "" {
		return fmt.Errorf("repo root is required")
	}
	if strings.TrimSpace(groupName) == "" {
		return fmt.Errorf("group name is required")
	}
	if len(targets) == 0 {
		return nil
	}

	bakeFile := filepath.Join(repoRoot, "docker-bake.hcl")
	if _, err := os.Stat(bakeFile); err != nil {
		return fmt.Errorf("bake file not found: %w", err)
	}

	tmpFile, err := writeBakeFile(groupName, targets)
	if err != nil {
		return err
	}
	defer func() { _ = os.Remove(tmpFile) }()

	builder := buildxBuilderName()
	args := []string{"buildx", "bake", "--builder", builder}
	args = append(args, bakeAllowArgs(targets)...)
	args = append(args, bakeProvenanceArgs()...)
	args = append(args, "-f", bakeFile, "-f", tmpFile)
	return withBuildLock("bake", func() error {
		if verbose {
			args = append(args, "--progress", "plain")
			args = append(args, groupName)
			return runner.Run(ctx, repoRoot, "docker", args...)
		}
		args = append(args, groupName)
		return runner.RunQuiet(ctx, repoRoot, "docker", args...)
	})
}

func writeBakeFile(groupName string, targets []bakeTarget) (string, error) {
	tmpFile, err := os.CreateTemp("", "esb-bake-*.hcl")
	if err != nil {
		return "", err
	}
	defer func() { _ = tmpFile.Close() }()

	content, err := renderBakeFile(groupName, targets)
	if err != nil {
		return "", err
	}
	if _, err := tmpFile.WriteString(content); err != nil {
		return "", err
	}
	return tmpFile.Name(), nil
}

func renderBakeFile(groupName string, targets []bakeTarget) (string, error) {
	if strings.TrimSpace(groupName) == "" {
		return "", fmt.Errorf("group name is required")
	}
	if len(targets) == 0 {
		return "", fmt.Errorf("targets are required")
	}

	var b strings.Builder
	b.WriteString("// Auto-generated by esb build. DO NOT EDIT.\n")
	b.WriteString(fmt.Sprintf("group %s {\n", hclQuote(groupName)))
	b.WriteString("  targets = [")
	for i, target := range targets {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString(hclQuote(target.Name))
	}
	b.WriteString("]\n")
	b.WriteString("}\n\n")

	for _, target := range targets {
		if strings.TrimSpace(target.Name) == "" {
			return "", fmt.Errorf("target name is required")
		}
		b.WriteString(fmt.Sprintf("target %s {\n", hclQuote(target.Name)))
		if target.Context != "" {
			b.WriteString(fmt.Sprintf("  context = %s\n", hclQuote(target.Context)))
		}
		if target.Dockerfile != "" {
			b.WriteString(fmt.Sprintf("  dockerfile = %s\n", hclQuote(target.Dockerfile)))
		}
		if len(target.Tags) > 0 {
			b.WriteString(fmt.Sprintf("  tags = %s\n", hclList(target.Tags)))
		}
		outputs := target.Outputs
		if len(outputs) == 0 {
			outputs = []string{"type=docker"}
		}
		b.WriteString(fmt.Sprintf("  output = %s\n", hclList(outputs)))
		writeHclMap(&b, "labels", target.Labels)
		writeHclMap(&b, "args", target.Args)
		writeHclMap(&b, "contexts", target.Contexts)
		if target.CacheDisabled {
			b.WriteString("  cache-from = []\n")
			b.WriteString("  cache-to = []\n")
		} else {
			if len(target.CacheFrom) > 0 {
				b.WriteString(fmt.Sprintf("  cache-from = %s\n", hclList(target.CacheFrom)))
			}
			if len(target.CacheTo) > 0 {
				b.WriteString(fmt.Sprintf("  cache-to = %s\n", hclList(target.CacheTo)))
			}
		}
		if len(target.Secrets) > 0 {
			b.WriteString(fmt.Sprintf("  secret = %s\n", hclList(target.Secrets)))
		}
		if target.NoCache {
			b.WriteString("  no-cache = true\n")
		}
		b.WriteString("}\n\n")
	}

	return b.String(), nil
}

func bakeProvenanceArgs() []string {
	mode, ok := provenanceMode()
	if !ok {
		return nil
	}
	return []string{fmt.Sprintf("--provenance=%s", mode)}
}

func provenanceMode() (string, bool) {
	value := strings.TrimSpace(os.Getenv("PROVENANCE"))
	if value == "" {
		return "mode=max", true
	}
	switch strings.ToLower(value) {
	case "0", "false", "off", "no":
		return "", false
	case "1", "true", "on", "yes":
		return "mode=max", true
	default:
		return value, true
	}
}

func resolveBakeOutputs(registry string, pushToRegistry, includeDocker bool) []string {
	var outputs []string
	if includeDocker || !pushToRegistry {
		outputs = append(outputs, "type=docker")
	}
	if pushToRegistry && strings.TrimSpace(registry) != "" {
		output := "type=registry"
		if isInsecureRegistry(registry) {
			output += ",registry.insecure=true"
		}
		outputs = append(outputs, output)
	}
	return outputs
}

func isInsecureRegistry(registry string) bool {
	if strings.TrimSpace(registry) == "" {
		return false
	}
	value := strings.ToLower(strings.TrimSpace(os.Getenv("CONTAINER_REGISTRY_INSECURE")))
	if value == "1" || value == "true" || value == "yes" {
		return true
	}
	host := registryHost(registry)
	switch strings.ToLower(strings.TrimSpace(host)) {
	case "registry", "localhost", "127.0.0.1":
		return true
	default:
		return false
	}
}

func registryHost(registry string) string {
	trimmed := strings.TrimSpace(registry)
	if trimmed == "" {
		return ""
	}
	trimmed = strings.TrimSuffix(trimmed, "/")
	trimmed = strings.TrimPrefix(trimmed, "http://")
	trimmed = strings.TrimPrefix(trimmed, "https://")
	if slash := strings.Index(trimmed, "/"); slash != -1 {
		trimmed = trimmed[:slash]
	}
	host := trimmed
	if colon := strings.Index(host, ":"); colon != -1 {
		host = host[:colon]
	}
	return host
}

func hclList(values []string) string {
	items := make([]string, 0, len(values))
	for _, value := range values {
		if strings.TrimSpace(value) == "" {
			continue
		}
		items = append(items, hclQuote(value))
	}
	return "[" + strings.Join(items, ", ") + "]"
}

func writeHclMap(b *strings.Builder, name string, values map[string]string) {
	if len(values) == 0 {
		return
	}
	keys := make([]string, 0, len(values))
	for key := range values {
		keys = append(keys, key)
	}
	sort.Strings(keys)
	b.WriteString(fmt.Sprintf("  %s = {\n", name))
	for _, key := range keys {
		b.WriteString(fmt.Sprintf("    %s = %s\n", hclQuote(key), hclQuote(values[key])))
	}
	b.WriteString("  }\n")
}

func hclQuote(value string) string {
	return strconv.Quote(value)
}

func dockerBuildArgMap() map[string]string {
	keys := []string{
		"HTTP_PROXY",
		"HTTPS_PROXY",
		"NO_PROXY",
		"http_proxy",
		"https_proxy",
		"no_proxy",
	}
	args := make(map[string]string)
	for _, key := range keys {
		value := strings.TrimSpace(os.Getenv(key))
		if value == "" {
			continue
		}
		args[key] = value
	}
	return args
}

var buildxProxyEnvKeys = []string{
	"HTTP_PROXY",
	"http_proxy",
	"HTTPS_PROXY",
	"https_proxy",
	"NO_PROXY",
	"no_proxy",
}

var buildxProxyEnvKeySet = map[string]struct{}{
	"HTTP_PROXY":  {},
	"http_proxy":  {},
	"HTTPS_PROXY": {},
	"https_proxy": {},
	"NO_PROXY":    {},
	"no_proxy":    {},
}

func resolveProxyValue(upper, lower, fallback string) string {
	if value := strings.TrimSpace(os.Getenv(upper)); value != "" {
		return value
	}
	if value := strings.TrimSpace(os.Getenv(lower)); value != "" {
		return value
	}
	return strings.TrimSpace(fallback)
}

func readDockerConfigProxy() map[string]string {
	configDir := strings.TrimSpace(os.Getenv("DOCKER_CONFIG"))
	if configDir == "" {
		home, err := os.UserHomeDir()
		if err != nil {
			return nil
		}
		configDir = filepath.Join(home, ".docker")
	}
	configPath := filepath.Join(configDir, "config.json")
	raw, err := os.ReadFile(configPath)
	if err != nil {
		return nil
	}
	var parsed struct {
		Proxies map[string]struct {
			HTTPProxy  string `json:"httpProxy"`
			HTTPSProxy string `json:"httpsProxy"`
			NoProxy    string `json:"noProxy"`
		} `json:"proxies"`
	}
	if err := json.Unmarshal(raw, &parsed); err != nil {
		return nil
	}
	defaults, ok := parsed.Proxies["default"]
	if !ok {
		return nil
	}
	values := make(map[string]string)
	if value := strings.TrimSpace(defaults.HTTPProxy); value != "" {
		values["httpProxy"] = value
	}
	if value := strings.TrimSpace(defaults.HTTPSProxy); value != "" {
		values["httpsProxy"] = value
	}
	if value := strings.TrimSpace(defaults.NoProxy); value != "" {
		values["noProxy"] = value
	}
	return values
}

func buildxProxyEnvMap() map[string]string {
	defaults := readDockerConfigProxy()
	pairs := []struct {
		upper      string
		lower      string
		configName string
	}{
		{upper: "HTTP_PROXY", lower: "http_proxy", configName: "httpProxy"},
		{upper: "HTTPS_PROXY", lower: "https_proxy", configName: "httpsProxy"},
		{upper: "NO_PROXY", lower: "no_proxy", configName: "noProxy"},
	}
	envs := make(map[string]string)
	for _, pair := range pairs {
		value := resolveProxyValue(pair.upper, pair.lower, defaults[pair.configName])
		if value == "" {
			continue
		}
		envs[pair.upper] = value
		envs[pair.lower] = value
	}
	return envs
}

func buildxProxyDriverEnvMap() map[string]string {
	envs := buildxProxyEnvMap()
	driverEnv := make(map[string]string)
	for key, value := range envs {
		if strings.Contains(value, ",") && strings.EqualFold(key, "no_proxy") {
			continue
		}
		driverEnv[key] = value
	}
	return driverEnv
}

func buildxProxyDriverOptsFromMap(envs map[string]string) []string {
	if len(envs) == 0 {
		return nil
	}
	keys := make([]string, 0, len(envs))
	for key := range envs {
		keys = append(keys, key)
	}
	sort.Strings(keys)
	opts := make([]string, 0, len(keys))
	for _, key := range keys {
		opts = append(opts, fmt.Sprintf("env.%s=%s", key, envs[key]))
	}
	return opts
}

func buildxBuilderProxyEnv(
	ctx context.Context,
	runner compose.CommandRunner,
	repoRoot string,
	builder string,
) (map[string]string, error) {
	containerName := fmt.Sprintf("buildx_buildkit_%s0", builder)
	output, err := runner.RunOutput(
		ctx,
		repoRoot,
		"docker",
		"inspect",
		"-f",
		"{{range .Config.Env}}{{println .}}{{end}}",
		containerName,
	)
	if err != nil {
		return nil, err
	}
	env := make(map[string]string)
	for _, line := range strings.Split(string(output), "\n") {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}
		key, value, ok := strings.Cut(line, "=")
		if !ok {
			continue
		}
		if _, ok := buildxProxyEnvKeySet[key]; ok {
			env[key] = value
		}
	}
	return env, nil
}

func buildxBuilderProxyMismatch(
	ctx context.Context,
	runner compose.CommandRunner,
	repoRoot string,
	builder string,
	desired map[string]string,
) (bool, error) {
	existing, err := buildxBuilderProxyEnv(ctx, runner, repoRoot, builder)
	if err != nil {
		return false, err
	}
	for _, key := range buildxProxyEnvKeys {
		desiredValue := strings.TrimSpace(desired[key])
		existingValue := strings.TrimSpace(existing[key])
		if desiredValue == "" {
			if existingValue != "" {
				return true, nil
			}
			continue
		}
		if existingValue != desiredValue {
			return true, nil
		}
	}
	return false, nil
}

func bakeAllowArgs(targets []bakeTarget) []string {
	readPaths := make(map[string]struct{})
	writePaths := make(map[string]struct{})
	for _, target := range targets {
		addBakeReadPath(readPaths, target.Context)
		for _, contextPath := range target.Contexts {
			addBakeReadPath(readPaths, contextPath)
		}
		for _, secret := range target.Secrets {
			path := parseBakeSecretPath(secret)
			if path == "" {
				continue
			}
			readPaths[path] = struct{}{}
		}
		for _, cache := range target.CacheFrom {
			path := parseBakeCachePath(cache, "src")
			if path == "" {
				continue
			}
			readPaths[path] = struct{}{}
		}
		for _, cache := range target.CacheTo {
			path := parseBakeCachePath(cache, "dest")
			if path == "" {
				continue
			}
			writePaths[path] = struct{}{}
		}
	}
	if len(readPaths) == 0 && len(writePaths) == 0 {
		return nil
	}
	args := make([]string, 0, len(readPaths)+len(writePaths))
	if len(readPaths) > 0 {
		ordered := make([]string, 0, len(readPaths))
		for path := range readPaths {
			ordered = append(ordered, path)
		}
		sort.Strings(ordered)
		for _, path := range ordered {
			args = append(args, "--allow=fs.read="+path)
		}
	}
	if len(writePaths) > 0 {
		ordered := make([]string, 0, len(writePaths))
		for path := range writePaths {
			ordered = append(ordered, path)
		}
		sort.Strings(ordered)
		for _, path := range ordered {
			args = append(args, "--allow=fs.write="+path)
		}
	}
	return args
}

func addBakeReadPath(readPaths map[string]struct{}, value string) {
	if strings.TrimSpace(value) == "" {
		return
	}
	if strings.HasPrefix(value, "target:") {
		return
	}
	if strings.Contains(value, "://") {
		return
	}
	if !filepath.IsAbs(value) {
		return
	}
	readPaths[value] = struct{}{}
}

func parseBakeSecretPath(spec string) string {
	return parseBakeKeyValuePath(spec, "src")
}

func parseBakeCachePath(spec, key string) string {
	return parseBakeKeyValuePath(spec, key)
}

func parseBakeKeyValuePath(spec, key string) string {
	for _, part := range strings.Split(spec, ",") {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}
		parsedKey, value, ok := strings.Cut(part, "=")
		if !ok {
			continue
		}
		if strings.TrimSpace(parsedKey) != key {
			continue
		}
		return strings.TrimSpace(value)
	}
	return ""
}

func bakeCacheRoot(outputBase string) string {
	if value := strings.TrimSpace(os.Getenv("BUILDX_CACHE_DIR")); value != "" {
		return value
	}
	return filepath.Join(outputBase, "buildx-cache")
}

type buildxBuilderOptions struct {
	NetworkMode string
	ConfigPath  string
}

func ensureBuildxBuilder(
	ctx context.Context,
	runner compose.CommandRunner,
	repoRoot string,
	opts buildxBuilderOptions,
) error {
	if runner == nil {
		return fmt.Errorf("command runner is nil")
	}
	root := strings.TrimSpace(repoRoot)
	if root == "" {
		return fmt.Errorf("repo root is required")
	}
	builder := buildxBuilderName()
	needsRecreate := false
	desiredProxyEnv := buildxProxyDriverEnvMap()
	return withBuildLock("buildx", func() error {
		output, err := runner.RunOutput(
			ctx,
			root,
			"docker",
			"buildx",
			"inspect",
			"--builder",
			builder,
		)
		if err == nil && strings.TrimSpace(opts.NetworkMode) != "" {
			mode, modeErr := buildxBuilderNetworkMode(ctx, runner, root, builder)
			if modeErr != nil || mode != opts.NetworkMode {
				needsRecreate = true
			}
		}
		if err == nil {
			proxyMismatch, proxyErr := buildxBuilderProxyMismatch(ctx, runner, root, builder, desiredProxyEnv)
			if proxyErr != nil || proxyMismatch {
				needsRecreate = true
			}
		}
		if err != nil || needsRecreate {
			if needsRecreate {
				_ = runner.Run(ctx, root, "docker", "buildx", "rm", builder)
			}
			createArgs := []string{
				"buildx",
				"create",
				"--name",
				builder,
				"--driver",
				"docker-container",
				"--use",
				"--bootstrap",
			}
			if strings.TrimSpace(opts.NetworkMode) != "" {
				createArgs = append(createArgs, "--driver-opt", fmt.Sprintf("network=%s", opts.NetworkMode))
			}
			if proxyOpts := buildxProxyDriverOptsFromMap(desiredProxyEnv); len(proxyOpts) > 0 {
				for _, opt := range proxyOpts {
					createArgs = append(createArgs, "--driver-opt", opt)
				}
			}
			if configPath := strings.TrimSpace(opts.ConfigPath); configPath != "" {
				if info, statErr := os.Stat(configPath); statErr == nil && !info.IsDir() {
					createArgs = append(createArgs, "--buildkitd-config", configPath)
				}
			}
			createOutput, createErr := runner.RunOutput(ctx, root, "docker", createArgs...)
			if createErr != nil {
				lower := strings.ToLower(string(createOutput))
				if strings.Contains(lower, "existing instance") || strings.Contains(lower, "already exists") {
					if strings.TrimSpace(opts.NetworkMode) != "" {
						if mode, modeErr := buildxBuilderNetworkMode(ctx, runner, root, builder); modeErr == nil && mode != opts.NetworkMode {
							return fmt.Errorf(
								"buildx builder %s uses network mode %s (expected %s)",
								builder,
								mode,
								opts.NetworkMode,
							)
						}
					}
					if err := runner.Run(ctx, root, "docker", "buildx", "use", builder); err != nil {
						return err
					}
				} else {
					return createErr
				}
			}
			output, err = runner.RunOutput(
				ctx,
				root,
				"docker",
				"buildx",
				"inspect",
				"--builder",
				builder,
				"--bootstrap",
			)
			if err != nil {
				return err
			}
		}
		driver := parseBuildxDriver(output)
		if driver == "" {
			return fmt.Errorf("buildx builder %s has no driver info", builder)
		}
		if !strings.EqualFold(driver, "docker-container") {
			return fmt.Errorf("buildx builder %s uses driver %s (expected docker-container)", builder, driver)
		}
		return nil
	})
}

func buildxBuilderNetworkMode(
	ctx context.Context,
	runner compose.CommandRunner,
	repoRoot string,
	builder string,
) (string, error) {
	containerName := fmt.Sprintf("buildx_buildkit_%s0", builder)
	output, err := runner.RunOutput(
		ctx,
		repoRoot,
		"docker",
		"inspect",
		"-f",
		"{{.HostConfig.NetworkMode}}",
		containerName,
	)
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(string(output)), nil
}

func parseBuildxDriver(output []byte) string {
	for _, line := range strings.Split(string(output), "\n") {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "Driver:") {
			return strings.TrimSpace(strings.TrimPrefix(line, "Driver:"))
		}
	}
	return ""
}

// applyBakeLocalCache configures local cache settings for a bake target.
// It appends to any existing CacheFrom/CacheTo settings, preserving configuration
// defined in the base docker-bake.hcl.
func applyBakeLocalCache(target *bakeTarget, cacheRoot, group string) error {
	if target == nil {
		return nil
	}
	if buildxCacheDisabled() {
		target.CacheDisabled = true
		return nil
	}
	if strings.TrimSpace(cacheRoot) == "" {
		return nil
	}
	parts := []string{}
	if strings.TrimSpace(group) != "" {
		parts = append(parts, group)
	}
	if strings.TrimSpace(target.Name) != "" {
		parts = append(parts, target.Name)
	}
	if len(parts) == 0 {
		return nil
	}
	cacheDir := filepath.Join(append([]string{cacheRoot}, sanitizePathSegments(parts)...)...)
	if err := os.MkdirAll(cacheDir, 0o755); err != nil {
		return err
	}
	target.CacheFrom = append(target.CacheFrom, fmt.Sprintf("type=local,src=%s", cacheDir))
	if strings.TrimSpace(os.Getenv("ESB_BUILDX_CACHE_TO")) != "0" {
		target.CacheTo = append(target.CacheTo, fmt.Sprintf("type=local,dest=%s,mode=max", cacheDir))
	}
	return nil
}

func buildxCacheDisabled() bool {
	value := strings.ToLower(strings.TrimSpace(os.Getenv("ESB_BUILDX_CACHE")))
	switch value {
	case "0", "false", "off", "no":
		return true
	default:
		return false
	}
}

func sanitizePathSegments(values []string) []string {
	segments := make([]string, 0, len(values))
	for _, value := range values {
		if cleaned := sanitizePathSegment(value); cleaned != "" {
			segments = append(segments, cleaned)
		}
	}
	return segments
}

func sanitizePathSegment(value string) string {
	trimmed := strings.TrimSpace(value)
	if trimmed == "" {
		return ""
	}
	cleaned := strings.NewReplacer(
		"/", "-",
		"\\", "-",
		":", "-",
		" ", "-",
	).Replace(trimmed)
	return cleaned
}

func mergeStringMap(base, extra map[string]string) map[string]string {
	out := make(map[string]string)
	for key, value := range base {
		out[key] = value
	}
	for key, value := range extra {
		out[key] = value
	}
	return out
}
