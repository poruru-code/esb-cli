// Where: cli/internal/infra/build/bake_hcl.go
// What: Bake HCL rendering and related helpers.
// Why: Keep output file generation separate from runtime execution flow.
package build

import (
	"fmt"
	"os"
	"sort"
	"strconv"
	"strings"
)

func writeBakeFile(groupName string, targets []bakeTarget) (string, error) {
	tmpFile, err := os.CreateTemp("", "esb-bake-*.hcl")
	if err != nil {
		return "", err
	}
	defer func() { _ = tmpFile.Close() }()

	content, err := renderBakeFile(groupName, targets)
	if err != nil {
		return "", err
	}
	if _, err := tmpFile.WriteString(content); err != nil {
		return "", err
	}
	return tmpFile.Name(), nil
}

func renderBakeFile(groupName string, targets []bakeTarget) (string, error) {
	if strings.TrimSpace(groupName) == "" {
		return "", fmt.Errorf("group name is required")
	}
	if len(targets) == 0 {
		return "", fmt.Errorf("targets are required")
	}

	var b strings.Builder
	b.WriteString("// Auto-generated by esb build. DO NOT EDIT.\n")
	b.WriteString(fmt.Sprintf("group %s {\n", hclQuote(groupName)))
	b.WriteString("  targets = [")
	for i, target := range targets {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString(hclQuote(target.Name))
	}
	b.WriteString("]\n")
	b.WriteString("}\n\n")

	for _, target := range targets {
		if strings.TrimSpace(target.Name) == "" {
			return "", fmt.Errorf("target name is required")
		}
		b.WriteString(fmt.Sprintf("target %s {\n", hclQuote(target.Name)))
		if target.Context != "" {
			b.WriteString(fmt.Sprintf("  context = %s\n", hclQuote(target.Context)))
		}
		if target.Dockerfile != "" {
			b.WriteString(fmt.Sprintf("  dockerfile = %s\n", hclQuote(target.Dockerfile)))
		}
		if len(target.Tags) > 0 {
			b.WriteString(fmt.Sprintf("  tags = %s\n", hclList(target.Tags)))
		}
		outputs := target.Outputs
		if len(outputs) == 0 {
			outputs = []string{"type=docker"}
		}
		b.WriteString(fmt.Sprintf("  output = %s\n", hclList(outputs)))
		writeHclMap(&b, "labels", target.Labels)
		writeHclMap(&b, "args", target.Args)
		writeHclMap(&b, "contexts", target.Contexts)
		if len(target.Secrets) > 0 {
			b.WriteString(fmt.Sprintf("  secret = %s\n", hclList(target.Secrets)))
		}
		if target.NoCache {
			b.WriteString("  no-cache = true\n")
		}
		b.WriteString("}\n\n")
	}

	return b.String(), nil
}

func hclList(values []string) string {
	items := make([]string, 0, len(values))
	for _, value := range values {
		if strings.TrimSpace(value) == "" {
			continue
		}
		items = append(items, hclQuote(value))
	}
	return "[" + strings.Join(items, ", ") + "]"
}

func writeHclMap(b *strings.Builder, name string, values map[string]string) {
	if len(values) == 0 {
		return
	}
	keys := make([]string, 0, len(values))
	for key := range values {
		keys = append(keys, key)
	}
	sort.Strings(keys)
	b.WriteString(fmt.Sprintf("  %s = {\n", name))
	for _, key := range keys {
		b.WriteString(fmt.Sprintf("    %s = %s\n", hclQuote(key), hclQuote(values[key])))
	}
	b.WriteString("  }\n")
}

func hclQuote(value string) string {
	return strconv.Quote(value)
}

func dockerBuildArgMap() map[string]string {
	keys := []string{
		"HTTP_PROXY",
		"HTTPS_PROXY",
		"NO_PROXY",
		"http_proxy",
		"https_proxy",
		"no_proxy",
	}
	args := make(map[string]string)
	for _, key := range keys {
		value := strings.TrimSpace(os.Getenv(key))
		if value == "" {
			continue
		}
		args[key] = value
	}
	return args
}
