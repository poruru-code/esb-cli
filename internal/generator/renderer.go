// Where: cli/internal/generator/renderer.go
// What: Render Dockerfile, functions.yml, and routing.yml outputs.
// Why: Provide Go equivalents of the Python generator templates.
package generator

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

const defaultSitecustomizeSource = "tools/generator/runtime/site-packages/sitecustomize.py"

type DockerConfig struct {
	SitecustomizeSource string
}

func RenderDockerfile(
	fn FunctionSpec,
	dockerConfig DockerConfig,
	registry string,
	tag string,
) (string, error) {
	if tag == "" {
		tag = "latest"
	}
	runtime := fn.Runtime
	if runtime == "" {
		runtime = "python3.12"
	}
	pythonVersion := strings.TrimPrefix(runtime, "python")
	if pythonVersion == runtime {
		pythonVersion = "3.12"
	}

	sitecustomize := dockerConfig.SitecustomizeSource
	if sitecustomize == "" {
		sitecustomize = defaultSitecustomizeSource
	}

	baseImage := "esb-lambda-base:" + tag
	if registry != "" {
		baseImage = fmt.Sprintf("%s/esb-lambda-base:%s", registry, tag)
	}

	context := map[string]any{
		"name":                 fn.Name,
		"python_version":       pythonVersion,
		"base_image":           baseImage,
		"sitecustomize_source": sitecustomize,
		"code_uri":             fn.CodeURI,
		"handler":              fn.Handler,
		"has_requirements":     fn.HasRequirements,
		"layers":               fn.Layers,
	}

	tmpl, err := template.New("Dockerfile").Parse(dockerfileTemplate)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, context); err != nil {
		return "", err
	}
	return buf.String(), nil
}

func RenderFunctionsYml(functions []FunctionSpec, registry, tag string) (string, error) {
	if tag == "" {
		tag = "latest"
	}

	output := map[string]any{
		"defaults": map[string]any{
			"environment": map[string]string{
				"GATEWAY_INTERNAL_URL":  "${GATEWAY_INTERNAL_URL}",
				"LOG_LEVEL":             "${LOG_LEVEL}",
				"AWS_ACCESS_KEY_ID":     "${RUSTFS_ACCESS_KEY}",
				"AWS_SECRET_ACCESS_KEY": "${RUSTFS_SECRET_KEY}",
				"AWS_DEFAULT_REGION":    "ap-northeast-1",
			},
			"scaling": map[string]any{
				"idle_timeout":    300,
				"acquire_timeout": 5.0,
			},
		},
		"functions": map[string]any{},
	}

	functionMap := output["functions"].(map[string]any)
	for _, fn := range functions {
		image := fmt.Sprintf("%s:%s", fn.Name, tag)
		if registry != "" {
			image = fmt.Sprintf("%s/%s:%s", registry, fn.Name, tag)
		}
		entry := map[string]any{
			"image": image,
		}
		if fn.Timeout > 0 {
			entry["timeout"] = fn.Timeout
		}
		if fn.MemorySize > 0 {
			entry["memory_size"] = fn.MemorySize
		}
		if len(fn.Environment) > 0 {
			entry["environment"] = fn.Environment
		}
		if fn.Scaling.MaxCapacity != nil || fn.Scaling.MinCapacity != nil {
			scaling := map[string]any{}
			if fn.Scaling.MaxCapacity != nil {
				scaling["max_capacity"] = *fn.Scaling.MaxCapacity
			}
			if fn.Scaling.MinCapacity != nil {
				scaling["min_capacity"] = *fn.Scaling.MinCapacity
			}
			entry["scaling"] = scaling
		}
		functionMap[fn.Name] = entry
	}

	payload, err := yaml.Marshal(output)
	if err != nil {
		return "", err
	}
	return string(payload), nil
}

func RenderRoutingYml(functions []FunctionSpec) (string, error) {
	routes := make([]map[string]any, 0)
	for _, fn := range functions {
		for _, event := range fn.Events {
			if event.Path == "" || event.Method == "" {
				continue
			}
			routes = append(routes, map[string]any{
				"path":     event.Path,
				"method":   strings.ToUpper(event.Method),
				"function": fn.Name,
			})
		}
	}

	output := map[string]any{"routes": routes}
	payload, err := yaml.Marshal(output)
	if err != nil {
		return "", err
	}
	return string(payload), nil
}

const dockerfileTemplate = `# Auto-generated by SAM Template Generator
# DO NOT EDIT MANUALLY - Regenerate with: esb build
# Source: template.yaml
# FunctionName: {{ .name }}


FROM {{ .base_image }}

# ESB Runtime
COPY {{ .sitecustomize_source }} /opt/python/sitecustomize.py

{{- range .layers }}
# Layer: {{ .Name }}
COPY {{ .ContentURI }}/ /opt/
{{- end }}
{{- if .has_requirements }}

# Function dependencies
COPY {{ .code_uri }}requirements.txt ${LAMBDA_TASK_ROOT}/
RUN pip install -r ${LAMBDA_TASK_ROOT}/requirements.txt
{{- end }}

# Function code
COPY {{ .code_uri }} ${LAMBDA_TASK_ROOT}/

# Handler
CMD [ "{{ .handler }}" ]
`
