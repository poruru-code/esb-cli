// Where: cli/internal/generator/bake.go
// What: Buildx bake helpers for parallel image builds.
// Why: Speed up ESB build phase by batching images with bake.
package generator

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"

	"github.com/poruru/edge-serverless-box/cli/internal/compose"
)

type bakeTarget struct {
	Name       string
	Context    string
	Dockerfile string
	Tags       []string
	Labels     map[string]string
	Args       map[string]string
	Contexts   map[string]string
	Secrets    []string
	CacheFrom  []string
	CacheTo    []string
	NoCache    bool
}

func runBakeGroup(
	ctx context.Context,
	runner compose.CommandRunner,
	repoRoot string,
	groupName string,
	targets []bakeTarget,
	verbose bool,
) error {
	if runner == nil {
		return fmt.Errorf("command runner is nil")
	}
	if strings.TrimSpace(repoRoot) == "" {
		return fmt.Errorf("repo root is required")
	}
	if strings.TrimSpace(groupName) == "" {
		return fmt.Errorf("group name is required")
	}
	if len(targets) == 0 {
		return nil
	}

	bakeFile := filepath.Join(repoRoot, "bake.hcl")
	if _, err := os.Stat(bakeFile); err != nil {
		return fmt.Errorf("bake file not found: %w", err)
	}

	tmpFile, err := writeBakeFile(groupName, targets)
	if err != nil {
		return err
	}
	defer func() { _ = os.Remove(tmpFile) }()

	args := []string{"buildx", "bake"}
	args = append(args, bakeAllowArgs(targets)...)
	args = append(args, "-f", bakeFile, "-f", tmpFile, "--load")
	return withBuildLock("bake", func() error {
		if verbose {
			args = append(args, "--progress", "plain")
			args = append(args, groupName)
			return runner.Run(ctx, repoRoot, "docker", args...)
		}
		args = append(args, groupName)
		return runner.RunQuiet(ctx, repoRoot, "docker", args...)
	})
}

func writeBakeFile(groupName string, targets []bakeTarget) (string, error) {
	tmpFile, err := os.CreateTemp("", "esb-bake-*.hcl")
	if err != nil {
		return "", err
	}
	defer func() { _ = tmpFile.Close() }()

	content, err := renderBakeFile(groupName, targets)
	if err != nil {
		return "", err
	}
	if _, err := tmpFile.WriteString(content); err != nil {
		return "", err
	}
	return tmpFile.Name(), nil
}

func renderBakeFile(groupName string, targets []bakeTarget) (string, error) {
	if strings.TrimSpace(groupName) == "" {
		return "", fmt.Errorf("group name is required")
	}
	if len(targets) == 0 {
		return "", fmt.Errorf("targets are required")
	}

	var b strings.Builder
	b.WriteString("// Auto-generated by esb build. DO NOT EDIT.\n")
	b.WriteString(fmt.Sprintf("group %s {\n", hclQuote(groupName)))
	b.WriteString("  targets = [")
	for i, target := range targets {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString(hclQuote(target.Name))
	}
	b.WriteString("]\n")
	b.WriteString("}\n\n")

	for _, target := range targets {
		if strings.TrimSpace(target.Name) == "" {
			return "", fmt.Errorf("target name is required")
		}
		b.WriteString(fmt.Sprintf("target %s {\n", hclQuote(target.Name)))
		if target.Context != "" {
			b.WriteString(fmt.Sprintf("  context = %s\n", hclQuote(target.Context)))
		}
		if target.Dockerfile != "" {
			b.WriteString(fmt.Sprintf("  dockerfile = %s\n", hclQuote(target.Dockerfile)))
		}
		if len(target.Tags) > 0 {
			b.WriteString(fmt.Sprintf("  tags = %s\n", hclList(target.Tags)))
		}
		writeHclMap(&b, "labels", target.Labels)
		writeHclMap(&b, "args", target.Args)
		writeHclMap(&b, "contexts", target.Contexts)
		if len(target.CacheFrom) > 0 {
			b.WriteString(fmt.Sprintf("  cache-from = %s\n", hclList(target.CacheFrom)))
		}
		if len(target.CacheTo) > 0 {
			b.WriteString(fmt.Sprintf("  cache-to = %s\n", hclList(target.CacheTo)))
		}
		if len(target.Secrets) > 0 {
			b.WriteString(fmt.Sprintf("  secret = %s\n", hclList(target.Secrets)))
		}
		if target.NoCache {
			b.WriteString("  no-cache = true\n")
		}
		b.WriteString("}\n\n")
	}

	return b.String(), nil
}

func hclList(values []string) string {
	items := make([]string, 0, len(values))
	for _, value := range values {
		if strings.TrimSpace(value) == "" {
			continue
		}
		items = append(items, hclQuote(value))
	}
	return "[" + strings.Join(items, ", ") + "]"
}

func writeHclMap(b *strings.Builder, name string, values map[string]string) {
	if len(values) == 0 {
		return
	}
	keys := make([]string, 0, len(values))
	for key := range values {
		keys = append(keys, key)
	}
	sort.Strings(keys)
	b.WriteString(fmt.Sprintf("  %s = {\n", name))
	for _, key := range keys {
		b.WriteString(fmt.Sprintf("    %s = %s\n", hclQuote(key), hclQuote(values[key])))
	}
	b.WriteString("  }\n")
}

func hclQuote(value string) string {
	return strconv.Quote(value)
}

func dockerBuildArgMap() map[string]string {
	keys := []string{
		"HTTP_PROXY",
		"HTTPS_PROXY",
		"NO_PROXY",
		"http_proxy",
		"https_proxy",
		"no_proxy",
	}
	args := make(map[string]string)
	for _, key := range keys {
		value := strings.TrimSpace(os.Getenv(key))
		if value == "" {
			continue
		}
		args[key] = value
	}
	return args
}

func bakeAllowArgs(targets []bakeTarget) []string {
	readPaths := make(map[string]struct{})
	writePaths := make(map[string]struct{})
	for _, target := range targets {
		for _, secret := range target.Secrets {
			path := parseBakeSecretPath(secret)
			if path == "" {
				continue
			}
			readPaths[path] = struct{}{}
		}
		for _, cache := range target.CacheFrom {
			path := parseBakeCachePath(cache, "src")
			if path == "" {
				continue
			}
			readPaths[path] = struct{}{}
		}
		for _, cache := range target.CacheTo {
			path := parseBakeCachePath(cache, "dest")
			if path == "" {
				continue
			}
			writePaths[path] = struct{}{}
		}
	}
	if len(readPaths) == 0 && len(writePaths) == 0 {
		return nil
	}
	args := make([]string, 0, len(readPaths)+len(writePaths))
	if len(readPaths) > 0 {
		ordered := make([]string, 0, len(readPaths))
		for path := range readPaths {
			ordered = append(ordered, path)
		}
		sort.Strings(ordered)
		for _, path := range ordered {
			args = append(args, "--allow=fs.read="+path)
		}
	}
	if len(writePaths) > 0 {
		ordered := make([]string, 0, len(writePaths))
		for path := range writePaths {
			ordered = append(ordered, path)
		}
		sort.Strings(ordered)
		for _, path := range ordered {
			args = append(args, "--allow=fs.write="+path)
		}
	}
	return args
}

func parseBakeSecretPath(spec string) string {
	return parseBakeKeyValuePath(spec, "src")
}

func parseBakeCachePath(spec, key string) string {
	return parseBakeKeyValuePath(spec, key)
}

func parseBakeKeyValuePath(spec, key string) string {
	for _, part := range strings.Split(spec, ",") {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}
		parsedKey, value, ok := strings.Cut(part, "=")
		if !ok {
			continue
		}
		if strings.TrimSpace(parsedKey) != key {
			continue
		}
		return strings.TrimSpace(value)
	}
	return ""
}

func bakeCacheRoot(outputBase string) string {
	return filepath.Join(outputBase, "buildx-cache")
}

func applyBakeLocalCache(target *bakeTarget, cacheRoot, group string) error {
	if target == nil || strings.TrimSpace(cacheRoot) == "" {
		return nil
	}
	parts := []string{}
	if strings.TrimSpace(group) != "" {
		parts = append(parts, group)
	}
	if strings.TrimSpace(target.Name) != "" {
		parts = append(parts, target.Name)
	}
	if len(parts) == 0 {
		return nil
	}
	cacheDir := filepath.Join(append([]string{cacheRoot}, sanitizePathSegments(parts)...)...)
	if err := os.MkdirAll(cacheDir, 0o755); err != nil {
		return err
	}
	target.CacheFrom = append(target.CacheFrom, fmt.Sprintf("type=local,src=%s", cacheDir))
	target.CacheTo = append(target.CacheTo, fmt.Sprintf("type=local,dest=%s,mode=max", cacheDir))
	return nil
}

func sanitizePathSegments(values []string) []string {
	segments := make([]string, 0, len(values))
	for _, value := range values {
		if cleaned := sanitizePathSegment(value); cleaned != "" {
			segments = append(segments, cleaned)
		}
	}
	return segments
}

func sanitizePathSegment(value string) string {
	trimmed := strings.TrimSpace(value)
	if trimmed == "" {
		return ""
	}
	cleaned := strings.NewReplacer(
		"/", "-",
		"\\", "-",
		":", "-",
		" ", "-",
	).Replace(trimmed)
	return cleaned
}

func mergeStringMap(base, extra map[string]string) map[string]string {
	out := make(map[string]string)
	for key, value := range base {
		out[key] = value
	}
	for key, value := range extra {
		out[key] = value
	}
	return out
}

func findBuildContextPath(buildContexts []buildContext, name string) (string, error) {
	for _, ctx := range buildContexts {
		if strings.TrimSpace(ctx.Name) == strings.TrimSpace(name) {
			if strings.TrimSpace(ctx.Path) == "" {
				return "", fmt.Errorf("build context path is empty for %s", name)
			}
			return ctx.Path, nil
		}
	}
	return "", fmt.Errorf("build context %s not found", name)
}
