import base64
import functools
import json
import logging
import os
import sys
import threading
import time
from datetime import datetime, timezone

import boto3
from botocore.config import Config

# --- Globals & Originals ---
_original_boto3_client = boto3.client
_trace_context = threading.local()

# --- Config ---
LOG_LEVEL_MAP = {"DEBUG": 10, "INFO": 20, "WARNING": 30, "ERROR": 40, "CRITICAL": 50}

SERVICE_CONFIG = {
    "s3": {
        "env_var": "S3_ENDPOINT",
        "config": Config(s3={"addressing_style": "path"}, signature_version="s3v4"),
    },
    "dynamodb": {
        "env_var": "DYNAMODB_ENDPOINT",
        "config": Config(
            retries={"max_attempts": 10, "mode": "standard"}, connect_timeout=5, read_timeout=5
        ),
    },
    "lambda": {
        "env_var": "GATEWAY_INTERNAL_URL",
        "config": Config(
            retries={"max_attempts": 10, "mode": "standard"}, connect_timeout=5, read_timeout=5
        ),
    },
}

# --- Helpers ---


def _get_current_trace_id():
    """Get the current Trace ID (dynamic capture > environment variable)."""
    return getattr(_trace_context, "current_trace_id", None) or os.environ.get("_X_AMZN_TRACE_ID")


def _get_current_request_id():
    """Get the current Request ID."""
    return getattr(_trace_context, "current_request_id", None)


def _sync_to_environ(trace_id):
    """Sync the Trace ID into os.environ (assist boto3 default behavior)."""
    if not trace_id:
        return
    os.environ["_X_AMZN_TRACE_ID"] = trace_id


def _log_json(message, level="INFO", **kwargs):
    """Emit internal sitecustomize logs as JSON."""
    entry = {
        "_time": datetime.now(timezone.utc).isoformat(timespec="milliseconds"),
        "level": level,
        "message": message,
        "logger": "sitecustomize",
        "trace_id": _get_current_trace_id(),
        "aws_request_id": _get_current_request_id(),
        "_sitecustomize": True,
    }
    entry.update(kwargs)
    try:
        sys.stderr.write(json.dumps(entry, ensure_ascii=False) + "\n")
    except Exception:
        pass


class JsonFormatter(logging.Formatter):
    def format(self, record):
        log_entry = {
            "level": record.levelname,
            "message": record.getMessage(),
            "timestamp": datetime.fromtimestamp(record.created, tz=timezone.utc).isoformat(),
            "logger": record.name,
            "trace_id": _get_current_trace_id(),
            "aws_request_id": _get_current_request_id(),
            "location": f"{record.filename}:{record.lineno}",
        }
        if record.exc_info:
            log_entry["exc_info"] = self.formatException(record.exc_info)
        return json.dumps(log_entry, ensure_ascii=False)


# --- Logging Logic Class ---


class LocalLogHandler:
    """Handles local log output."""

    @staticmethod
    def _get_iso8601_ms(ts_ms):
        dt = datetime.fromtimestamp(ts_ms / 1000.0, tz=timezone.utc)
        return dt.isoformat(timespec="milliseconds")

    @staticmethod
    def _estimate_container_name(log_group):
        # Use AWS_LAMBDA_FUNCTION_NAME; return UNKNOWN if unset.
        return os.environ.get("AWS_LAMBDA_FUNCTION_NAME", "UNKNOWN")

    @classmethod
    def handle_put_log_events(cls, client, **kwargs):
        try:
            log_group = kwargs.get("logGroupName", "unknown")
            log_stream = kwargs.get("logStreamName", "unknown")
            log_events = kwargs.get("logEvents", [])
            container_name = cls._estimate_container_name(log_group)

            current_threshold = LOG_LEVEL_MAP.get(os.environ.get("LOG_LEVEL", "INFO").upper(), 20)

            # Read VictoriaLogs URL from environment.
            vl_url = os.environ.get("VICTORIALOGS_URL")

            for event in log_events:
                msg = event.get("message", "")
                ts_ms = event.get("timestamp", int(time.time() * 1000))

                level = "INFO"
                clean_msg = msg
                for lvl in LOG_LEVEL_MAP.keys():
                    if msg.startswith(f"[{lvl}]"):
                        level = lvl
                        clean_msg = msg[len(f"[{lvl}]") :].lstrip()
                        break

                if LOG_LEVEL_MAP.get(level, 20) < current_threshold:
                    continue

                log_entry = {
                    "_time": cls._get_iso8601_ms(ts_ms),
                    "level": level,
                    "message": clean_msg,
                    "log_group": log_group,
                    "log_stream": log_stream,
                    "logger": "boto3.mock",
                    "container_name": container_name,
                    "job": "lambda",
                    "trace_id": _get_current_trace_id(),
                    "aws_request_id": _get_current_request_id(),
                }

                # Write to stdout (for Docker json-file driver).
                print(json.dumps(log_entry, ensure_ascii=False), flush=True)

                # Send directly to VictoriaLogs (when env var is set).
                if vl_url:
                    cls._send_to_victorialogs(vl_url, log_entry, container_name)

            return {"nextSequenceToken": "mock-token"}
        except Exception as e:
            print(f"[sitecustomize] Error in LocalLogHandler: {e}", flush=True)
            raise e

    @classmethod
    def _send_to_victorialogs(cls, vl_url, log_entry, container_name):
        """Send via HTTP POST to VictoriaLogs; no-op on failure (stdout already used)."""
        import urllib.error
        import urllib.parse
        import urllib.request

        try:
            params = urllib.parse.urlencode(
                {
                    "_stream_fields": "container_name,job",
                    "_msg_field": "message",
                    "_time_field": "_time",
                    "container_name": container_name,
                    "job": "lambda",
                }
            )
            full_url = f"{vl_url.rstrip('/')}/insert/jsonline?{params}"

            data = json.dumps(log_entry, ensure_ascii=False).encode("utf-8")
            req = urllib.request.Request(
                full_url,
                data=data,
                headers={"Content-Type": "application/json"},
                method="POST",
            )

            with urllib.request.urlopen(req, timeout=0.5) as res:
                res.read()
        except Exception:
            # Ignore send failures (stdout already written).
            pass


# --- Logic: VictoriaLogs Hook Class ---


class VictoriaLogsStdoutHook:
    """Hook stdout and also send writes to VictoriaLogs."""

    def __init__(self, original_stream, container_name, vl_url):
        self._original = original_stream
        self._container_name = container_name
        self._vl_url = vl_url

    def write(self, buf):
        # Write to original stdout.
        self._original.write(buf)

        # Also send to VictoriaLogs (skip empty/whitespace-only).
        if self._vl_url and buf.strip():
            for line in buf.rstrip().splitlines():
                if line.strip():
                    self._send_to_victorialogs(line)

    def _send_to_victorialogs(self, message):
        import urllib.error
        import urllib.parse
        import urllib.request

        try:
            # Determine whether it's JSON.
            try:
                log_entry = json.loads(message)
            except (json.JSONDecodeError, ValueError):
                # Ensure string type.
                if isinstance(message, bytes):
                    try:
                        msg_str = message.decode("utf-8", errors="replace")
                    except Exception:
                        msg_str = str(message)
                else:
                    msg_str = str(message)

                # Infer level (search tags/keywords case-insensitively).
                msg_upper = msg_str.upper()
                level = "INFO"
                if "DEBUG" in msg_upper or "TRACE" in msg_upper:
                    level = "DEBUG"
                elif "WARN" in msg_upper:
                    level = "WARNING"
                elif "ERROR" in msg_upper or "CRIT" in msg_upper:
                    level = "ERROR"

                log_entry = {
                    "_time": datetime.now(timezone.utc).isoformat(timespec="milliseconds"),
                    "level": level,
                    "message": msg_str,
                }

            # Add container_name and job (do not overwrite existing values).
            if "container_name" not in log_entry:
                log_entry["container_name"] = self._container_name
            if "job" not in log_entry:
                log_entry["job"] = "lambda"

            # Auto-attach Trace ID.
            if "trace_id" not in log_entry:
                tid = _get_current_trace_id()
                if tid:
                    log_entry["trace_id"] = tid

            # Auto-attach Request ID.
            if "aws_request_id" not in log_entry:
                rid = _get_current_request_id()
                if rid:
                    log_entry["aws_request_id"] = rid

            # Convert timestamp -> _time (for consistency).
            if "_time" not in log_entry:
                if "timestamp" in log_entry:
                    log_entry["_time"] = log_entry.pop("timestamp")
                else:
                    log_entry["_time"] = datetime.now(timezone.utc).isoformat(
                        timespec="milliseconds"
                    )

            params = urllib.parse.urlencode(
                {
                    "_stream_fields": "container_name,job",
                    "_msg_field": "message",
                    "_time_field": "_time",
                    "container_name": self._container_name,
                    "job": "lambda",
                }
            )
            full_url = f"{self._vl_url.rstrip('/')}/insert/jsonline?{params}"

            data = json.dumps(log_entry, ensure_ascii=False).encode("utf-8")
            req = urllib.request.Request(
                full_url,
                data=data,
                headers={"Content-Type": "application/json"},
                method="POST",
            )

            # Use longer timeout for robustness
            with urllib.request.urlopen(req, timeout=2.0) as res:
                res.read()
        except Exception:
            # Ignore send failures (stdout already written).
            pass

    def flush(self):
        self._original.flush()

    def __getattr__(self, name):
        return getattr(self._original, name)


# --- Logic: Auto Trace ID Hydration (Monkey Patching awslambdaric) ---


def _patch_awslambdaric():
    """
    Monkey-patch awslambdaric.bootstrap.handle_event_request to hydrate Trace ID
    and forward stdout/stderr to VictoriaLogs.
    """
    try:
        import awslambdaric.bootstrap  # type: ignore[unresolved-import]
    except ImportError:
        # Skip for local environments or different runtimes.
        print("[sitecustomize] awslambdaric not found, skipping patch.", flush=True)
        return

    original_handle_event_request = awslambdaric.bootstrap.handle_event_request

    @functools.wraps(original_handle_event_request)
    def patched_handle_event_request(
        lambda_runtime_client,
        request_handler,
        invoke_id,
        event_body,
        content_type,
        client_context,
        *args,
        **kwargs,
    ):
        # Set up stdout/stderr hooks.
        # Do this before hydration to capture hydration logs.
        original_stdout = sys.stdout
        original_stderr = sys.stderr
        vl_url = os.environ.get("VICTORIALOGS_URL")
        container_name = os.environ.get("AWS_LAMBDA_FUNCTION_NAME", "lambda-unknown")

        if vl_url:
            sys.stdout = VictoriaLogsStdoutHook(original_stdout, container_name, vl_url)
            sys.stderr = VictoriaLogsStdoutHook(original_stderr, container_name, vl_url)

        # Trace ID Hydration
        try:
            ctx = client_context
            trace_id = None

            if ctx:
                # If passed as a JSON string, attempt to parse.
                if isinstance(ctx, str):
                    try:
                        ctx = json.loads(ctx)
                    except Exception:
                        pass

                # Extract trace_id from dict or object.
                # Gateway uses 'trace_id'; AWS/boto3 uses '_X_AMZN_TRACE_ID'.
                if isinstance(ctx, dict):
                    custom = ctx.get("custom")
                    if isinstance(custom, dict):
                        trace_id = custom.get("trace_id") or custom.get("_X_AMZN_TRACE_ID")
                elif hasattr(ctx, "custom"):
                    custom = getattr(ctx, "custom", None)
                    if isinstance(custom, dict):
                        trace_id = custom.get("trace_id") or custom.get("_X_AMZN_TRACE_ID")

            # Request ID Hydration
            _trace_context.current_request_id = invoke_id

            if trace_id:
                os.environ["_X_AMZN_TRACE_ID"] = trace_id
                _trace_context.current_trace_id = trace_id
                _log_json(f"Hydrated _X_AMZN_TRACE_ID: {trace_id}", level="DEBUG")

        except Exception as e:
            _log_json(f"Error hydrating trace id: {e}", level="ERROR")

        try:
            return original_handle_event_request(
                lambda_runtime_client,
                request_handler,
                invoke_id,
                event_body,
                content_type,
                client_context,
                *args,
                **kwargs,
            )
        finally:
            # Restore stdout/stderr.
            sys.stdout = original_stdout
            sys.stderr = original_stderr

            # Mitigation for log loss in short-lived containers on Windows
            try:
                sys.stdout.flush()
                sys.stderr.flush()
            except Exception:
                pass
            time.sleep(0.1)

    awslambdaric.bootstrap.handle_event_request = patched_handle_event_request
    print(
        "[sitecustomize] awslambdaric.bootstrap.handle_event_request "
        "patched for Trace ID hydration and VictoriaLogs.",
        flush=True,
    )


# --- Logic: ClientContext Injection (For RIE) ---


def _inject_client_context_hook(params, **kwargs):
    """
    [Important] Lambda RIE workaround.
    RIE ignores the X-Amzn-Trace-Id HTTP header, so inject trace_id into
    the custom field of ClientContext.
    Event: provide-client-params.lambda.Invoke
    """
    trace_id = _get_current_trace_id()
    if not trace_id:
        return

    # Decode existing ClientContext (if any).
    ctx_data = {}
    if "ClientContext" in params:
        try:
            ctx_data = json.loads(base64.b64decode(params["ClientContext"]).decode("utf-8"))
        except Exception as e:
            print(
                f"[sitecustomize] Warning: Failed to decode existing ClientContext: {e}", flush=True
            )

    # Inject trace_id into the custom section.
    if "custom" not in ctx_data:
        ctx_data["custom"] = {}

    # Set only if not already present.
    if "trace_id" not in ctx_data["custom"]:
        ctx_data["custom"]["trace_id"] = trace_id

        # Re-encode and update params.
        json_str = json.dumps(ctx_data)
        b64_str = base64.b64encode(json_str.encode("utf-8")).decode("utf-8")
        params["ClientContext"] = b64_str

        print(
            f"[sitecustomize] Injected Trace ID into ClientContext for RIE: {trace_id}", flush=True
        )


# --- Separated Patch Logic ---


def _create_mock_logs_client(args, kwargs):
    """Create a local mock client for CloudWatch Logs."""
    print(
        "[sitecustomize] Creating original boto3 client for logs (local mock mode)...", flush=True
    )
    client = _original_boto3_client("logs", *args, **kwargs)
    _original_make_api_call = client._make_api_call

    def _patched_make_api_call(operation_name, api_params):
        if operation_name == "PutLogEvents":
            return LocalLogHandler.handle_put_log_events(client, **api_params)
        if operation_name in (
            "CreateLogGroup",
            "CreateLogStream",
            "DeleteLogGroup",
            "DeleteLogStream",
        ):
            return {}
        if operation_name == "DescribeLogGroups":
            return {"logGroups": []}
        if operation_name == "DescribeLogStreams":
            return {"logStreams": []}
        return _original_make_api_call(operation_name, api_params)

    client._make_api_call = _patched_make_api_call
    return client


def _configure_service_endpoint(service_name, kwargs):
    """Inject endpoint settings based on environment variables."""
    service_cfg = SERVICE_CONFIG.get(service_name)
    if not service_cfg:
        return

    # Check multiple possible environment variable names
    env_vars = [service_cfg["env_var"]]
    if service_name == "s3":
        env_vars.append("AWS_ENDPOINT_URL_S3")
    elif service_name == "dynamodb":
        env_vars.append("AWS_ENDPOINT_URL_DYNAMODB")
    elif service_name == "lambda":
        env_vars.append("GATEWAY_INTERNAL_URL")  # Already in env_var, but for clarity

    endpoint = None
    for ev in env_vars:
        endpoint = os.environ.get(ev)
        if endpoint:
            break

    if endpoint:
        endpoint = endpoint.strip()
        kwargs["endpoint_url"] = endpoint
        kwargs["verify"] = False
        if service_cfg["config"]:
            existing = kwargs.get("config")
            kwargs["config"] = (
                existing.merge(service_cfg["config"]) if existing else service_cfg["config"]
            )
        print(f"[sitecustomize] Redirecting {service_name} to {endpoint}", flush=True)


def _register_lambda_hooks(client):
    """Register ClientContext injection hook for Lambda Invoke."""
    client.meta.events.register("provide-client-params.lambda.Invoke", _inject_client_context_hook)
    print("[sitecustomize] Registered ClientContext hook for lambda.Invoke", flush=True)


def _patched_boto3_client(service_name, *args, **kwargs):
    try:
        # 1. Logs (mock) case.
        if service_name == "logs":
            return _create_mock_logs_client(args, kwargs)

        # 2. Other services (endpoint redirection).
        _configure_service_endpoint(service_name, kwargs)

        # Create client.
        client = _original_boto3_client(service_name, *args, **kwargs)

        # 3. Lambda case (hook registration).
        if service_name == "lambda":
            _register_lambda_hooks(client)

        return client

    except Exception as e:
        print(f"[sitecustomize] Error in _patched_boto3_client for {service_name}: {e}", flush=True)
        import traceback

        traceback.print_exc()
        raise e


# --- Logic: Logging Module Patch (Standard Python Logging) ---


def _patch_logging():
    root = logging.getLogger()
    for h in root.handlers:
        root.removeHandler(h)

    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(JsonFormatter())
    root.addHandler(handler)

    # Respect existing environment log level settings.
    root.setLevel(os.environ.get("LOG_LEVEL", "INFO").upper())
    _log_json("Patched standard logging to output JSON.")


# --- Apply Patches ---

boto3.client = _patched_boto3_client  # ty: ignore[invalid-assignment]  # monkey-patch for local endpoint redirection

# Patch awslambdaric
_patch_awslambdaric()

# Patch logging
_patch_logging()

_log_json(f"Loaded. boto3 ID: {id(boto3)}")
_log_json("All patches applied. RIE Trace ID bridge enabled.")
