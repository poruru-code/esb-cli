// Where: cli/internal/domain/template/renderer.go
// What: Render Dockerfile, functions.yml, and routing.yml outputs.
// Why: Provide Go equivalents of the Python generator templates.
package template

import (
	"bytes"
	"embed"
	"fmt"
	"path"
	"strings"
	"sync"
	"text/template"

	"github.com/poruru/edge-serverless-box/cli/internal/domain/runtime"
	"github.com/poruru/edge-serverless-box/meta"

	"github.com/Masterminds/sprig/v3"
	"github.com/poruru/edge-serverless-box/cli/internal/domain/manifest"
	"gopkg.in/yaml.v3"
)

// DefaultSitecustomizeSource is the default sitecustomize.py path used by the build pipeline.
const DefaultSitecustomizeSource = "cli/internal/infra/build/assets/python/site-packages/sitecustomize.py"

//go:embed templates/*.tmpl
var templateFS embed.FS

var templateCache sync.Map

func RenderDockerfile(
	fn FunctionSpec,
	dockerConfig DockerConfig,
	registry string,
	tag string,
) (string, error) {
	if tag == "" {
		tag = "latest"
	}
	registry = normalizeRegistry(registry)
	profile, err := runtime.Resolve(fn.Runtime)
	if err != nil {
		return "", err
	}

	sitecustomize := dockerConfig.SitecustomizeSource
	if sitecustomize == "" {
		sitecustomize = DefaultSitecustomizeSource
	}

	lambdaBase := meta.ImagePrefix + "-lambda-base"
	baseImage := lambdaBase + ":" + tag
	if profile.Kind == runtime.KindJava {
		if profile.JavaBaseImage == "" {
			return "", fmt.Errorf("java base image is required for runtime %s", profile.Name)
		}
		baseImage = profile.JavaBaseImage
	} else if registry != "" {
		baseImage = fmt.Sprintf("%s%s:%s", registry, lambdaBase, tag)
	}

	handler := fn.Handler
	originalHandler := ""
	useJavaWrapper := false
	javaWrapperSource := ""
	if profile.UsesJavaWrapper {
		originalHandler = handler
		handler = "com.runtime.lambda.HandlerWrapper::handleRequest"
		useJavaWrapper = true
		javaWrapperSource = path.Join("functions", fn.Name, "lambda-java-wrapper.jar")
	}

	data := dockerfileTemplateData{
		Name:                fn.Name,
		BaseImage:           baseImage,
		SitecustomizeSource: sitecustomize,
		UseSitecustomize:    profile.UsesSitecustomize,
		UsePip:              profile.UsesPip && fn.HasRequirements,
		UseJavaWrapper:      useJavaWrapper,
		JavaWrapperSource:   javaWrapperSource,
		OriginalHandler:     originalHandler,
		CodeURI:             fn.CodeURI,
		Handler:             handler,
		Layers:              fn.Layers,
		PythonVersion:       profile.PythonVersion,
	}

	return renderTemplate("dockerfile.tmpl", data)
}

func RenderFunctionsYml(functions []FunctionSpec, registry, tag string) (string, error) {
	_ = registry
	_ = tag

	data := functionsTemplateData{}
	for _, fn := range functions {
		if strings.TrimSpace(fn.ImageName) == "" {
			return "", fmt.Errorf("image name is required for function %s", fn.Name)
		}
		hasSchedules := false
		for _, e := range fn.Events {
			if e.Type == "Schedule" {
				hasSchedules = true
				break
			}
		}
		entry := functionTemplateContext{
			Name:         fn.Name,
			Timeout:      optionalInt(fn.Timeout),
			MemorySize:   optionalInt(fn.MemorySize),
			Environment:  fn.Environment,
			Events:       fn.Events,
			HasSchedules: hasSchedules,
		}
		if fn.Scaling.MaxCapacity != nil || fn.Scaling.MinCapacity != nil {
			scaling := map[string]any{}
			if fn.Scaling.MaxCapacity != nil {
				scaling["max_capacity"] = *fn.Scaling.MaxCapacity
			}
			if fn.Scaling.MinCapacity != nil {
				scaling["min_capacity"] = *fn.Scaling.MinCapacity
			}
			entry.Scaling = scaling
		}
		data.Functions = append(data.Functions, entry)
	}

	return renderTemplate("functions.yml.tmpl", data)
}

func RenderRoutingYml(functions []FunctionSpec) (string, error) {
	data := routingTemplateData{}
	for _, fn := range functions {
		entry := routingFunction{
			Name:   fn.Name,
			Events: fn.Events,
		}
		data.Functions = append(data.Functions, entry)
	}
	return renderTemplate("routing.yml.tmpl", data)
}

func RenderResourcesYml(spec manifest.ResourcesSpec) (string, error) {
	resources := map[string]any{}
	if len(spec.DynamoDB) > 0 {
		resources["dynamodb"] = spec.DynamoDB
	}
	if len(spec.S3) > 0 {
		resources["s3"] = spec.S3
	}
	if len(spec.Layers) > 0 {
		resources["layers"] = spec.Layers
	}
	payload := map[string]any{
		"resources": resources,
	}
	data, err := yaml.Marshal(payload)
	if err != nil {
		return "", err
	}
	header := "# Auto-generated by SAM Template Generator\n# DO NOT EDIT MANUALLY - Regenerate with: esb deploy\n\n"
	return header + string(data), nil
}

func renderTemplate(name string, data any) (string, error) {
	tmpl, err := loadTemplate(name)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", err
	}
	return buf.String(), nil
}

func loadTemplate(name string) (*template.Template, error) {
	if value, ok := templateCache.Load(name); ok {
		cached, ok := value.(*template.Template)
		if !ok {
			return nil, fmt.Errorf("template cache type mismatch for %s", name)
		}
		return cached, nil
	}
	tmpl, err := template.New(name).Funcs(sprig.TxtFuncMap()).ParseFS(templateFS, "templates/"+name)
	if err != nil {
		return nil, err
	}
	templateCache.Store(name, tmpl)
	return tmpl, nil
}

type dockerfileTemplateData struct {
	Name                string
	BaseImage           string
	SitecustomizeSource string
	UseSitecustomize    bool
	UsePip              bool
	UseJavaWrapper      bool
	JavaWrapperSource   string
	OriginalHandler     string
	CodeURI             string
	Handler             string
	Layers              []manifest.LayerSpec
	PythonVersion       string
}

type functionsTemplateData struct {
	Functions []functionTemplateContext
}

type functionTemplateContext struct {
	Name         string
	Timeout      *int
	MemorySize   *int
	Environment  map[string]string
	Scaling      map[string]any
	Events       []EventSpec
	HasSchedules bool
}

type routingTemplateData struct {
	Functions []routingFunction
}

type routingFunction struct {
	Name   string
	Events []EventSpec
}

func normalizeRegistry(value string) string {
	value = strings.TrimSpace(value)
	if value == "" {
		return ""
	}
	if strings.HasSuffix(value, "/") {
		return value
	}
	return value + "/"
}

func optionalInt(value int) *int {
	if value == 0 {
		return nil
	}
	result := value
	return &result
}
